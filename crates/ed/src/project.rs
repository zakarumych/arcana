//! Ed works with projects.
//!
//! Project is a directory with `bob.toml` file.
//!
//! When Ed starts, first thing user does is open a project, existing or new.
//! The project always has a Rust package with cdylib target.
//!
//! Ed uses `cargo` to build the project and runs it, connecting to it via RPC.
//! Package is generated by Ed and is not intended to be edited by user.
//!
//! When user adds a plugin library to the project the Ed adds it to the `Cargo.toml` file as dependency.
//!
//! After build Ed links to the built project library and fetches information about the plugins.
//! Then it may run instances of the game with different plugins enabled.
//!
//! On project lib rebuild Ed saves state of the running instances,
//! rebuilds the library and links to it, tries to restore the state.
//! If state can't be restored, Ed ask user what to do - loose state or keep running instance from old library version.
//!

use std::{
    fmt,
    fs::File,
    io::{Read, Seek, SeekFrom, Write},
    path::{Path, PathBuf},
    sync::Arc,
};

use bob::{
    events::{Event, EventLoop},
    nix,
};
use hashbrown::HashMap;
use parking_lot::Mutex;

use crate::api::{version, ProjectLibrary};

/// Project dependency.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
enum Dependency {
    // Fetch from the crates.io
    Crates(String),

    // Fetch from the git repository
    Git { git: String, branch: Option<String> },

    // Fetch from the local path
    Path { path: String },
}

impl fmt::Display for Dependency {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Dependency::Crates(version) => write!(f, "\"{}\"", version),
            Dependency::Git { git, branch } => {
                if let Some(branch) = branch {
                    write!(f, "{{ git = \"{git}\", branch = \"{branch}\" }}")
                } else {
                    write!(f, "{{ git = \"{git}\" }}")
                }
            }
            Dependency::Path { path } => {
                write!(f, "{{ path = \"{}\" }}", path.escape_default())
            }
        }
    }
}

/// Project manifest.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "kebab-case")]
struct ProjectManifest {
    name: String,

    /// List of plugin libraries this project depends on.
    /// They are added to the generated `Cargo.toml` file for project's crate.
    #[serde(skip_serializing_if = "HashMap::is_empty", default)]
    plugin_libs: HashMap<String, Dependency>,

    /// How to fetch ed dependency.
    /// If `None` defaults to
    #[serde(
        skip_serializing_if = "is_default_ed_dependency",
        default = "default_ed_dependency"
    )]
    ed: Dependency,
}

fn default_ed_dependency() -> Dependency {
    Dependency::Crates(version().to_owned())
}

fn is_default_ed_dependency(dep: &Dependency) -> bool {
    match dep {
        Dependency::Crates(v) => v == version(),
        _ => false,
    }
}

/// Project object.
///
/// When this object exists, it is synced to the corresponding "bob.toml" file.
/// Opened project locks the "bob.toml" file.
pub struct Project {
    path: PathBuf,
    file: File,
    manifest: ProjectManifest,
}

impl fmt::Debug for Project {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Project").field("path", &self.path).finish()
    }
}

impl Drop for Project {
    fn drop(&mut self) {
        if let Err(err) = self.sync() {
            tracing::error!("Failed to sync project manifest: {}", err);
        }
    }
}

impl Project {
    /// Create new project at the given path.
    /// The path must be a directory that not occupied by any other entity.
    /// If path is a directory, there must be no "bob.toml" file inside it.
    pub fn new(name: String, path: &Path) -> miette::Result<Self> {
        match path.metadata() {
            Err(_) => {
                std::fs::create_dir_all(&path).map_err(|err| {
                    miette::miette!(
                        "Cannot create project at {}, failed to create directory: {err}",
                        path.display()
                    )
                })?;
            }
            Ok(metadata) => {
                if !metadata.is_dir() {
                    miette::bail!(
                        "Cannot create project at {}, path is not a directory",
                        path.display()
                    );
                }

                if path.join("bob.toml").exists() {
                    miette::bail!(
                        "{} already contains a project, cannot create project there",
                        path.display()
                    );
                }
            }
        }

        let path = dunce::canonicalize(path).expect("existing path");

        let manifest = ProjectManifest {
            name,
            plugin_libs: HashMap::new(),
            ed: default_ed_dependency(),
        };

        let file = std::fs::File::create(path.join("bob.toml")).map_err(|err| {
            miette::miette!(
                "Cannot create project at {}, failed to create \"bob.toml\": {err}",
                path.display()
            )
        })?;

        let mut project = Project {
            path,
            file,
            manifest,
        };

        project.sync()?;
        project.init_package()?;
        Ok(project)
    }

    /// Create new project at the given path.
    /// The path must be a directory that already exists.
    /// New directory with the project name will be created inside it
    /// and the project will be created there.
    pub fn new_in(name: String, path: &Path) -> miette::Result<Self> {
        match path.metadata() {
            Ok(metadata) => {
                if metadata.is_dir() {
                    let path = path.join(&name);
                    Self::new(name, &path)
                } else {
                    miette::bail!(
                        "Cannot create project in {}, path is not a directory",
                        path.display()
                    );
                }
            }
            Err(err) => {
                miette::bail!("Cannot create project in {}: {}", path.display(), err);
            }
        }
    }

    pub fn open(path: &Path) -> miette::Result<Self> {
        let mut file = std::fs::File::options()
            .read(true)
            .write(true)
            .open(path.join("bob.toml"))
            .map_err(|err| {
                miette::miette!(
                    "Cannot open project at {}, failed to open \"bob.toml\": {err}",
                    path.display()
                )
            })?;

        let mut bob_toml = String::new();
        file.read_to_string(&mut bob_toml).map_err(|err| {
            miette::miette!(
                "Cannot read project manifest from \"{}\\bob.toml\": {err}",
                path.display()
            )
        })?;

        let manifest: ProjectManifest = toml::from_str(&bob_toml).map_err(|err| {
            miette::miette!("Cannot deserialize project manifest from \"bob.toml\": {err}")
        })?;

        let project = Project {
            path: dunce::canonicalize(path).expect("existing path"),
            file,
            manifest,
        };

        Ok(project)
    }

    pub fn name(&self) -> &str {
        &self.manifest.name
    }

    pub fn add_library_path(&mut self, path: &Path) -> miette::Result<()> {
        let path_str = path.to_str().ok_or_else(|| {
            miette::miette!(
                "Cannot add library path \"{}\": path is not valid UTF-8",
                path.display()
            )
        })?;

        let cargo_toml_path = path.join("Cargo.toml");

        let cargo_toml = std::fs::read_to_string(&cargo_toml_path).map_err(|err| {
            miette::miette!(
                "Cannot read Cargo.toml from \"{}\": {err}",
                cargo_toml_path.display()
            )
        })?;

        let manifest = cargo_toml::Manifest::from_str(&cargo_toml).map_err(|err| {
            miette::miette!(
                "Cannot read Cargo.toml from \"{}\": {err}",
                cargo_toml_path.display()
            )
        })?;

        let package = manifest.package.as_ref().ok_or_else(|| {
            miette::miette!("Not a package manifest: \"{}\"", cargo_toml_path.display())
        })?;

        self.manifest.plugin_libs.insert(
            package.name.clone(),
            Dependency::Path {
                path: path_str.to_owned(),
            },
        );

        self.sync()?;

        Ok(())
    }

    fn sync(&mut self) -> miette::Result<()> {
        let content = toml::to_string_pretty(&self.manifest).map_err(|err| {
            miette::miette!("Cannot serialize project manifest to \"bob.toml\": {err}")
        })?;

        self.write_to_file(&content).map_err(|err| {
            miette::miette!(
                "Cannot write project manifest to \"{}\\bob.toml\": {err}",
                self.path.display()
            )
        })?;

        Ok(())
    }

    fn write_to_file(&mut self, content: &str) -> std::io::Result<()> {
        self.file.seek(SeekFrom::Start(0))?;
        self.file.set_len(0)?;
        self.file.write_all(content.as_bytes())
    }

    /// Returns content for `Cargo.toml` file.
    fn cargo_toml(&self) -> String {
        let mut cargo_toml = format!(
            r#"
[package]
name = "{name}"
version = "0.0.0"
edition = "2021"
publish = false

[lib]
crate-type = ["cdylib"]

[dependencies]
ed = {ed}
"#,
            name = self.manifest.name.escape_default(),
            ed = self.manifest.ed,
        );

        for (name, dep) in &self.manifest.plugin_libs {
            cargo_toml.push_str(&format!("{} = {}\n", name, dep));
        }

        cargo_toml
    }

    fn lib_rs(&self) -> String {
        let mut lib_rs = "ed::ed_lib![".to_owned();
        for lib in &self.manifest.plugin_libs {
            lib_rs.push_str(&lib.0.replace('-', "_"));
            lib_rs.push(',');
        }
        lib_rs.push_str("];");
        lib_rs
    }

    fn init_package(&self) -> miette::Result<()> {
        if !self.path.exists() {
            std::fs::create_dir_all(&self.path).map_err(|err| {
                miette::miette!(
                    "Failed to create build directory at {}: {err}",
                    self.path.display()
                )
            })?;
        }

        let cargo_toml_path = self.path.join("Cargo.toml");
        std::fs::write(&cargo_toml_path, self.cargo_toml()).map_err(|err| {
            miette::miette!(
                "Failed to write Cargo.toml to {}: {err}",
                cargo_toml_path.display()
            )
        })?;

        let src_path = self.path.join("src");
        if !src_path.exists() {
            std::fs::create_dir_all(&src_path).map_err(|err| {
                miette::miette!(
                    "Failed to create src directory at {}: {err}",
                    src_path.display()
                )
            })?;
        }

        let src_lib_rs_path = src_path.join("lib.rs");
        std::fs::write(&src_lib_rs_path, self.lib_rs()).map_err(|err| {
            miette::miette!(
                "Failed to write src/lib.rs to {}: {err}",
                src_lib_rs_path.display()
            )
        })?;

        Ok(())
    }

    pub fn build(&self, instance: &mut Option<ProjectInstance>) -> miette::Result<()> {
        self.init_package()?;

        let result = std::process::Command::new("cargo")
            .arg("build")
            .arg("--lib")
            .arg(format!("--package={}", self.manifest.name))
            .current_dir(&self.path)
            .status();

        match result {
            Err(err) => {
                return Err(miette::miette!("Failed to run cargo build: {}", err));
            }
            Ok(status) if !status.success() => {
                return Err(miette::miette!(
                    "Failed build project: {}",
                    status.to_string()
                ));
            }
            Ok(_) => {}
        }

        let workspace = find_workspace_target(&self.path);
        let target_path = workspace.join("target").join("debug");

        let mut bin = ProjectLibrary::new(&self.manifest.name, &target_path)?;

        let mut new_plugins = HashMap::new();

        for (lib, plugins) in bin.list_plugins() {
            let lib = new_plugins.entry(lib).or_insert_with(HashMap::new);

            for plugin in plugins {
                lib.insert(plugin, false);
            }
        }

        if let Some(old) = &*instance {
            for (lib, old_plugins) in &old.plugins {
                if let Some(new_plugins) = new_plugins.get_mut(lib) {
                    for (plugin, enabled) in new_plugins {
                        if let Some(old_enabled) = old_plugins.get(plugin) {
                            *enabled = *old_enabled;
                        }
                    }
                }
            }
        }

        *instance = Some(ProjectInstance {
            plugins: new_plugins,
            bin,
        });

        Ok(())
    }
}

pub struct ProjectInstance {
    plugins: HashMap<String, HashMap<String, bool>>,
    bin: ProjectLibrary,
}

impl ProjectInstance {
    pub fn plugins(&self) -> &HashMap<String, HashMap<String, bool>> {
        &self.plugins
    }

    pub fn plugins_enabled_mut(
        &mut self,
    ) -> impl Iterator<Item = (&str, impl Iterator<Item = (&str, &mut bool)>)> {
        self.plugins.iter_mut().map(|(lib, plugins)| {
            (
                &**lib,
                plugins
                    .iter_mut()
                    .map(|(plugin, enabled)| (&**plugin, enabled)),
            )
        })
    }

    pub fn launch(
        &mut self,
        events: &EventLoop,
        device: &nix::Device,
        queue: &Arc<Mutex<nix::Queue>>,
    ) {
        self.bin.launch(
            events,
            device,
            queue,
            self.plugins.iter().flat_map(|(lib, plugins)| {
                plugins.iter().filter_map(move |(plugin, enabled)| {
                    if *enabled {
                        Some((&**lib, &**plugin))
                    } else {
                        None
                    }
                })
            }),
        );
    }

    pub fn on_event(&mut self, event: Event) -> Option<Event> {
        self.bin.on_event(event)
    }

    pub fn tick(&mut self) {
        self.bin.tick();
    }
}

fn find_workspace_target(path: &Path) -> &Path {
    let mut candidate = path;
    let mut next = Some(path);

    while let Some(path) = next {
        if path.join("Cargo.toml").is_file() {
            candidate = path;
        }
        next = path.parent();
    }

    candidate
}
