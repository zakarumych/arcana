//! Ed works with projects.
//!
//! Project is a directory with `bob.toml` file.
//!
//! When Ed starts, first thing user does is open a project, existing or new.
//! The project always has a Rust package with cdylib target.
//!
//! Ed uses `cargo` to build the project and runs it, connecting to it via RPC.
//! Package is generated by Ed and is not intended to be edited by user.
//!
//! When user adds a plugin library to the project the Ed adds it to the `Cargo.toml` file as dependency.
//!
//! After build Ed links to the built project library and fetches information about the plugins.
//! Then it may run instances of the game with different plugins enabled.
//!
//! On project lib rebuild Ed saves state of the running instances,
//! rebuilds the library and links to it, tries to restore the state.
//! If state can't be restored, Ed ask user what to do - loose state or keep running instance from old library version.
//!

use std::{
    fmt,
    fs::File,
    io::{BufRead, BufReader, Read, Seek, SeekFrom, Write},
    net::{Ipv4Addr, TcpStream},
    path::{Path, PathBuf},
};

use bob::events::{Event, EventLoop};
use ed_api::ProjectBinary;
use hashbrown::HashMap;
use rand::Rng;

/// Project dependency.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
enum Dependency {
    // Fetch from the crates.io
    Crates(String),

    // Fetch from the git repository
    Git { git: String, branch: Option<String> },

    // Fetch from the local path
    Path { path: String },
}

impl Dependency {
    fn to_string(&self, root: &Path) -> String {
        match self {
            Dependency::Crates(version) => format!("\"{}\"", version),
            Dependency::Git { git, branch } => {
                if let Some(branch) = branch {
                    format!("{{ git = \"{git}\", branch = \"{branch}\" }}")
                } else {
                    format!("{{ git = \"{git}\" }}")
                }
            }
            Dependency::Path { path } => {
                let path = root.join(path);

                format!(
                    "{{ path = \"{}\" }}",
                    path.to_string_lossy().escape_default()
                )
            }
        }
    }
}

/// Project manifest.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "kebab-case")]
struct ProjectManifest {
    name: String,

    /// List of plugin libraries this project depends on.
    /// They are added to the generated `Cargo.toml` file for project's crate.
    #[serde(skip_serializing_if = "HashMap::is_empty", default)]
    plugin_libs: HashMap<String, Dependency>,

    /// How to fetch ed_api dependency.
    /// If `None` defaults to
    #[serde(
        skip_serializing_if = "is_default_ed_api_dependency",
        default = "default_ed_api_dependency"
    )]
    ed_api: Dependency,
}

fn default_ed_api_dependency() -> Dependency {
    Dependency::Crates(ed_api::version().to_owned())
}

fn is_default_ed_api_dependency(dep: &Dependency) -> bool {
    match dep {
        Dependency::Crates(version) => version == ed_api::version(),
        _ => false,
    }
}

/// Project object.
///
/// When this object exists, it is synced to the corresponding "bob.toml" file.
/// Opened project locks the "bob.toml" file.
pub struct Project {
    path: PathBuf,
    file: File,
    manifest: ProjectManifest,
}

impl fmt::Debug for Project {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Project").field("path", &self.path).finish()
    }
}

impl Drop for Project {
    fn drop(&mut self) {
        if let Err(err) = self.sync() {
            tracing::error!("Failed to sync project manifest: {}", err);
        }
    }
}

impl Project {
    /// Create new project at the given path.
    /// The path must be a directory that not occupied by any other entity.
    /// If path is a directory, there must be no "bob.toml" file inside it.
    pub fn new(name: String, path: &Path) -> miette::Result<Self> {
        match path.metadata() {
            Err(_) => {
                std::fs::create_dir_all(&path).map_err(|err| {
                    miette::miette!(
                        "Cannot create project at {}, failed to create directory: {}",
                        path.display(),
                        err
                    )
                })?;
            }
            Ok(metadata) => {
                if !metadata.is_dir() {
                    miette::bail!(
                        "Cannot create project at {}, path is not a directory",
                        path.display()
                    );
                }

                if path.join("bob.toml").exists() {
                    miette::bail!(
                        "{} already contains a project, cannot create project there",
                        path.display()
                    );
                }
            }
        }

        let path = dunce::canonicalize(path).expect("existing path");

        let manifest = ProjectManifest {
            name,
            plugin_libs: HashMap::new(),
            ed_api: default_ed_api_dependency(),
        };

        let file = std::fs::File::create(path.join("bob.toml")).map_err(|err| {
            miette::miette!(
                "Cannot create project at {}, failed to create \"bob.toml\": {}",
                path.display(),
                err
            )
        })?;

        let mut project = Project {
            path,
            file,
            manifest,
        };

        project.sync()?;
        project.init_package()?;
        Ok(project)
    }

    /// Create new project at the given path.
    /// The path must be a directory that already exists.
    /// New directory with the project name will be created inside it
    /// and the project will be created there.
    pub fn new_in(name: String, path: &Path) -> miette::Result<Self> {
        match path.metadata() {
            Ok(metadata) => {
                if metadata.is_dir() {
                    let path = path.join(&name);
                    Self::new(name, &path)
                } else {
                    miette::bail!(
                        "Cannot create project in {}, path is not a directory",
                        path.display()
                    );
                }
            }
            Err(err) => {
                miette::bail!("Cannot create project in {}: {}", path.display(), err);
            }
        }
    }

    pub fn open(path: &Path) -> miette::Result<Self> {
        let mut file = std::fs::File::options()
            .read(true)
            .write(true)
            .open(path.join("bob.toml"))
            .map_err(|err| {
                miette::miette!(
                    "Cannot open project at {}, failed to open \"bob.toml\": {}",
                    path.display(),
                    err
                )
            })?;

        let mut bob_toml = String::new();
        file.read_to_string(&mut bob_toml).map_err(|err| {
            miette::miette!(
                "Cannot read project manifest from \"{}\\bob.toml\": {}",
                path.display(),
                err
            )
        })?;

        let manifest: ProjectManifest = toml::from_str(&bob_toml).map_err(|err| {
            miette::miette!(
                "Cannot deserialize project manifest from \"bob.toml\": {}",
                err
            )
        })?;

        let project = Project {
            path: dunce::canonicalize(path).expect("existing path"),
            file,
            manifest,
        };

        Ok(project)
    }

    pub fn name(&self) -> &str {
        &self.manifest.name
    }

    pub fn add_library_path(&mut self, path: &Path) -> miette::Result<()> {
        let path_str = path.to_str().ok_or_else(|| {
            miette::miette!(
                "Cannot add library path \"{}\": path is not valid UTF-8",
                path.display()
            )
        })?;

        let cargo_toml_path = path.join("Cargo.toml");

        let cargo_toml = std::fs::read_to_string(&cargo_toml_path).map_err(|err| {
            miette::miette!(
                "Cannot read Cargo.toml from \"{}\": {}",
                cargo_toml_path.display(),
                err
            )
        })?;

        let manifest = cargo_toml::Manifest::from_str(&cargo_toml).map_err(|err| {
            miette::miette!(
                "Cannot read Cargo.toml from \"{}\": {}",
                cargo_toml_path.display(),
                err
            )
        })?;

        let package = manifest.package.as_ref().ok_or_else(|| {
            miette::miette!("Not a package manifest: \"{}\"", cargo_toml_path.display())
        })?;

        self.manifest.plugin_libs.insert(
            package.name.clone(),
            Dependency::Path {
                path: path_str.to_owned(),
            },
        );

        self.sync()?;

        Ok(())
    }

    fn sync(&mut self) -> miette::Result<()> {
        let content = toml::to_string_pretty(&self.manifest).map_err(|err| {
            miette::miette!("Cannot serialize project manifest to \"bob.toml\": {}", err)
        })?;

        self.write_to_file(&content).map_err(|err| {
            miette::miette!(
                "Cannot write project manifest to \"{}\\bob.toml\": {}",
                self.path.display(),
                err
            )
        })?;

        Ok(())
    }

    fn write_to_file(&mut self, content: &str) -> std::io::Result<()> {
        self.file.seek(SeekFrom::Start(0))?;
        self.file.set_len(0)?;
        self.file.write_all(content.as_bytes())
    }

    /// Returns content for `Cargo.toml` file.
    fn cargo_toml(&self) -> String {
        let ed_api = self.manifest.ed_api.to_string(&self.path);

        let mut cargo_toml = format!(
            r#"
[package]
name = "{name}"
version = "0.0.0"
edition = "2021"
publish = false
[dependencies]
ed-api = {ed_api}
"#,
            name = self.manifest.name.escape_default(),
        );

        for (name, dep) in &self.manifest.plugin_libs {
            cargo_toml.push_str(&format!("{} = {}\n", name, dep.to_string(&self.path)));
        }

        cargo_toml
    }

    fn main_rs(&self) -> String {
        let mut lib_rs = "ed_api::ed_main![".to_owned();
        for lib in &self.manifest.plugin_libs {
            lib_rs.push_str(&lib.0.replace('-', "_"));
            lib_rs.push(',');
        }
        lib_rs.push_str("];");
        lib_rs
    }

    fn init_package(&self) -> miette::Result<()> {
        let build_path = self.path.join("build");

        if !build_path.exists() {
            std::fs::create_dir_all(&build_path).map_err(|err| {
                miette::miette!(
                    "Failed to create build directory at {}: {}",
                    build_path.display(),
                    err
                )
            })?;
        }

        let gitignore_path = build_path.join(".gitignore");
        std::fs::write(&gitignore_path, "*").map_err(|err| {
            miette::miette!(
                "Failed to write .gitignore to {}: {}",
                gitignore_path.display(),
                err
            )
        })?;

        let cargo_toml_path = build_path.join("Cargo.toml");
        std::fs::write(&cargo_toml_path, self.cargo_toml()).map_err(|err| {
            miette::miette!(
                "Failed to write Cargo.toml to {}: {}",
                cargo_toml_path.display(),
                err
            )
        })?;

        let src_path = build_path.join("src");
        if !src_path.exists() {
            std::fs::create_dir_all(&src_path).map_err(|err| {
                miette::miette!(
                    "Failed to create src directory at {}: {}",
                    src_path.display(),
                    err
                )
            })?;
        }

        let src_main_rs_path = src_path.join("main.rs");
        std::fs::write(&src_main_rs_path, self.main_rs()).map_err(|err| {
            miette::miette!(
                "Failed to write src/main.rs to {}: {}",
                src_main_rs_path.display(),
                err
            )
        })?;

        Ok(())
    }

    pub fn build(&self, instance: &mut Option<ProjectInstance>) -> miette::Result<()> {
        self.init_package()?;

        let build_path = self.path.join("build");

        let result = std::process::Command::new("cargo")
            .arg("build")
            .arg(format!("--package={}", self.manifest.name))
            .status();

        match result {
            Err(err) => {
                return Err(miette::miette!("Failed to run cargo build: {}", err));
            }
            Ok(status) if !status.success() => {
                return Err(miette::miette!(
                    "Failed build project: {}",
                    status.to_string()
                ));
            }
            Ok(_) => {}
        }

        let workspace = find_workspace_target(&build_path);
        let target_path = workspace.join("target").join("debug");
        let bin_name = format!("{}{}", &self.manifest.name, std::env::consts::EXE_SUFFIX);
        let bin_path = target_path.join(&bin_name);

        let bin_path = tmp_bin_path(&bin_path).map_err(|err| {
            miette::miette!(
                "Failed to copy library from {} to {}: {}",
                bin_path.display(),
                self.path.display(),
                err
            )
        })?;

        let mut bin = ProjectBinary::new(&bin_path);

        let mut new_plugins = HashMap::new();

        for (lib, plugins) in bin.list_plugins() {
            let lib = new_plugins.entry(lib).or_insert_with(HashMap::new);

            for plugin in plugins {
                lib.insert(plugin, false);
            }
        }

        if let Some(old) = &*instance {
            for (lib, old_plugins) in &old.plugins {
                if let Some(new_plugins) = new_plugins.get_mut(lib) {
                    for (plugin, enabled) in new_plugins {
                        if let Some(old_enabled) = old_plugins.get(plugin) {
                            *enabled = *old_enabled;
                        }
                    }
                }
            }
        }

        *instance = Some(ProjectInstance {
            path: bin_path,
            plugins: new_plugins,
            bin,
        });

        Ok(())
    }
}

pub struct ProjectInstance {
    path: PathBuf,
    plugins: HashMap<String, HashMap<String, bool>>,
    bin: ProjectBinary,
}

impl Drop for ProjectInstance {
    fn drop(&mut self) {
        self.bin.exit();

        if let Err(err) = std::fs::remove_file(&self.path) {
            tracing::error!(
                "Failed to remove library at {}: {}",
                self.path.display(),
                err
            );
        }
    }
}

impl ProjectInstance {
    pub fn plugins(&self) -> &HashMap<String, HashMap<String, bool>> {
        &self.plugins
    }

    pub fn plugins_enabled_mut(
        &mut self,
    ) -> impl Iterator<Item = (&str, impl Iterator<Item = (&str, &mut bool)>)> {
        self.plugins.iter_mut().map(|(lib, plugins)| {
            (
                &**lib,
                plugins
                    .iter_mut()
                    .map(|(plugin, enabled)| (&**plugin, enabled)),
            )
        })
    }

    pub fn launch(&mut self) {
        self.bin
            .launch(self.plugins.iter().flat_map(|(lib, plugins)| {
                plugins.iter().filter_map(move |(plugin, enabled)| {
                    if *enabled {
                        Some((&**lib, &**plugin))
                    } else {
                        None
                    }
                })
            }));
    }

    pub fn tick(&mut self) {
        self.bin.tick();
    }
}

fn find_workspace_target(path: &Path) -> &Path {
    let mut candidate = path;
    let mut next = Some(path);

    while let Some(path) = next {
        if path.join("Cargo.toml").is_file() {
            candidate = path;
        }
        next = path.parent();
    }

    candidate
}

fn tmp_bin_path(path: &Path) -> miette::Result<PathBuf> {
    let mut rng = rand::thread_rng();
    let dir = std::env::temp_dir();
    let filename = path
        .file_name()
        .ok_or_else(|| miette::miette!("Failed to get filename from path: {}", path.display()))?;
    let filename = filename.to_string_lossy();
    loop {
        let r: u128 = rng.gen();
        let filename = format!("{filename}_{r:0X}");

        let tmp_path = dir.join(&filename);
        if tmp_path.exists() {
            continue;
        }

        std::fs::copy(path, &tmp_path).map_err(|err| {
            miette::miette!(
                "Failed to copy library from {} to {}: {}",
                path.display(),
                tmp_path.display(),
                err
            )
        })?;

        return Ok(tmp_path);
    }
}
