//! This module provides a type that can be used to replace `TypeId` and is guaranteed to be stable.
//!
//! `Stid` is 64bit long semi-random value that is associated with a type
//! via derive macro or manual implementation of `HasStid` trait.
//!
//! User may provide specific identifier number for a type, it must be unique,
//! it must not have most significant bit set to 1,
//! it must not be 0.
//!
//! If not provided, the identifier is generated by hashing the type definition
//! and setting most significant bit to 1.
//! Thus the identifier is stable across different runs and compilations of the program,
//! unless the type definition changes and the identifier is not provided.
//!
//! Generics use the identifier number and hash them with the type parameters identifiers
//! to produce identifier for the concrete generic type instance.
//!

use arcana_proc::has_stid;
use gametime::TimeSpan;

crate::make_uid! {
    /// Stable Type Identifier.
    ///
    /// Identifier is assigned via `HasStid` trait.
    /// The trait can be implemented manually, derived or implemented by `has_stid!` macro.
    ///
    /// Derive macro and proc-macro allow specifying the identifier value.
    /// If not specified, the value is generated by hashing macro input with stable hash.
    ///
    /// Generated identifier will always have MSB set to 1.
    /// This ensures that manually set identifiers with MSB set to 0 will never collide with generated ones.
    pub Stid;
}

/// Trait for types that have stable identifier.
/// Derive it, implement manually or use `has_stid!` macro.
pub trait HasStid: 'static {
    fn stid() -> Stid
    where
        Self: Sized;

    fn stid_dyn(&self) -> Stid;
}

impl Stid {
    /// Returns stable identifier of a type.
    pub fn of<T>() -> Self
    where
        T: HasStid,
    {
        T::stid()
    }

    /// Returns stable identifier of a value's type.
    /// This works for trait objects.
    pub fn of_val<T>(value: &T) -> Self
    where
        T: HasStid + ?Sized,
    {
        value.stid_dyn()
    }
}

has_stid!(u8 = 0x0000_0000_0000_0001);
has_stid!(u16 = 0x0000_0000_0000_0002);
has_stid!(u32 = 0x0000_0000_0000_0003);
has_stid!(u64 = 0x0000_0000_0000_0004);
has_stid!(i8 = 0x0000_0000_0000_0005);
has_stid!(i16 = 0x0000_0000_0000_0006);
has_stid!(i32 = 0x0000_0000_0000_0007);
has_stid!(i64 = 0x0000_0000_0000_0008);
has_stid!(f32 = 0x0000_0000_0000_0009);
has_stid!(f64 = 0x0000_0000_0000_000A);

has_stid!(TimeSpan = 0x0000_0000_0000_00041);
has_stid!(::edict::entity::EntityId = 0x0000_0000_0000_0042);
