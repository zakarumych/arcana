//! Ed works with projects.
//!
//! Project is a directory with `Arcana.toml` file.
//!
//! When Ed starts, first thing user does is open a project, existing or new.
//! The project always has a Rust package with cdylib target.
//!
//! Ed uses `cargo` to build the project and runs it, connecting to it via RPC.
//! Package is generated by Ed and is not intended to be edited by user.
//!
//! When user adds a plugin library to the project the Ed adds it to the `Cargo.toml` file as dependency.
//!
//! After build Ed links to the built project library and fetches information about the plugins.
//! Then it may run instances of the game with different plugins enabled.
//!
//! On project lib rebuild Ed saves state of the running instances,
//! rebuilds the library and links to it, tries to restore the state.
//! If state can't be restored, Ed ask user what to do - loose state or keep running instance from old library version.
//!

use std::{
    fmt,
    fs::File,
    io::{Read, Seek, SeekFrom, Write},
    path::{Path, PathBuf},
    sync::Arc,
};

use arcana::{
    events::{Event, EventLoop},
    mev,
};
use hashbrown::HashMap;
use parking_lot::Mutex;

use crate::api::ProjectLibrary;

/// Project dependency.
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
pub enum Dependency {
    // Fetch from the crates.io
    Crates(String),

    // Fetch from the git repository
    Git { git: String, branch: Option<String> },

    // Fetch from the local path
    Path { path: String },
}

impl fmt::Display for Dependency {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Dependency::Crates(version) => write!(f, "\"{}\"", version),
            Dependency::Git { git, branch } => {
                if let Some(branch) = branch {
                    write!(f, "{{ git = \"{git}\", branch = \"{branch}\" }}")
                } else {
                    write!(f, "{{ git = \"{git}\" }}")
                }
            }
            Dependency::Path { path } => {
                write!(f, "{{ path = \"{}\" }}", path.escape_default())
            }
        }
    }
}

/// Project manifest.
#[derive(serde::Serialize, serde::Deserialize)]
#[serde(rename_all = "kebab-case")]
pub struct ProjectManifest {
    pub name: String,

    /// List of plugin libraries this project depends on.
    #[serde(skip_serializing_if = "HashMap::is_empty", default)]
    pub plugin_libs: HashMap<String, Dependency>,

    /// How to fetch arcana dependency.
    /// Defaults to `Dependency::Crates(version())`.
    #[serde(
        skip_serializing_if = "is_default_arcana_dependency",
        default = "default_arcana_dependency"
    )]
    pub arcana: Dependency,
}

impl ProjectManifest {
    pub fn new(name: String) -> Self {
        ProjectManifest {
            name,
            plugin_libs: HashMap::new(),
            arcana: default_arcana_dependency(),
        }
    }
}

pub fn default_arcana_dependency() -> Dependency {
    Dependency::Crates(arcana::version().to_owned())
}

fn is_default_arcana_dependency(dep: &Dependency) -> bool {
    match dep {
        Dependency::Crates(v) => v == arcana::version(),
        _ => false,
    }
}

/// Project object.
///
/// When this object exists, it is synced to the corresponding "Arcana.toml" file.
/// Opened project locks the "Arcana.toml" file.
pub struct Project {
    path: PathBuf,
    file: File,
    manifest: ProjectManifest,
}

impl fmt::Debug for Project {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("Project").field("path", &self.path).finish()
    }
}

impl Drop for Project {
    fn drop(&mut self) {
        if let Err(err) = self.sync() {
            tracing::error!("Failed to sync project manifest: {}", err);
        }
    }
}

impl Project {
    pub fn new(
        path: PathBuf,
        name: Option<String>,
        arcana: Option<Dependency>,
        new: bool,
    ) -> miette::Result<Self> {
        let name = match &name {
            None => {
                let Some(file_name) = path.file_name() else {
                    miette::bail!("Failed to get project name destination path");
                };

                if file_name.is_empty() || file_name == "." || file_name == ".." {
                    miette::bail!("Failed to get project name destination path");
                }

                let Some(file_name) = file_name.to_str() else {
                    miette::bail!("Failed to get project name destination path");
                };

                file_name
            }
            Some(name) => name,
        };
        if name.is_empty() {
            miette::bail!("Project name cannot be empty");
        }
        if !name.chars().next().unwrap().is_alphabetic() {
            miette::bail!("Project name must start with a letter");
        }
        if name.contains(invalid_name_character) {
            miette::bail!("Project name must contain only alphanumeric characters and underscores");
        }
        let Ok(cd) = std::env::current_dir() else {
            miette::bail!("Failed to get current directory");
        };

        let project_path = cd.join(&*path);
        let project_toml_path = project_path.join("Arcana.toml");
        let project_path_meta = project_path.metadata();
        if new {
            if project_path_meta.is_ok() {
                miette::bail!("Destination '{}' already exists", path.display());
            }
            if let Err(err) = std::fs::create_dir_all(&project_path) {
                miette::bail!(
                    "Failed to create project directory '{}'. {err}",
                    path.display()
                );
            };
        } else {
            match project_path_meta {
                Err(_) => {
                    if let Err(err) = std::fs::create_dir_all(&project_path) {
                        miette::bail!(
                            "Failed to create project directory '{}'. {err}",
                            path.display()
                        );
                    };
                }
                Ok(meta) => {
                    if !meta.is_dir() {
                        miette::bail!("Destination '{}' is not a directory", path.display());
                    }
                    if project_toml_path.exists() {
                        miette::bail!("Project already initialized");
                    }
                }
            }
        }

        let manifest = ProjectManifest {
            name: name.to_owned(),
            plugin_libs: HashMap::new(),
            arcana: arcana.unwrap_or_else(default_arcana_dependency),
        };

        let manifest_str = match toml::to_string(&manifest) {
            Ok(s) => s,
            Err(err) => {
                miette::bail!("Failed to serialize project manifest. {err}");
            }
        };

        let mut project_file = match std::fs::File::options()
            .create_new(true)
            .read(true)
            .write(true)
            .open(&project_toml_path)
        {
            Ok(f) => f,
            Err(err) => {
                miette::bail!(
                    "Failed to create project manifest at '{}'. {err}",
                    project_toml_path.display()
                );
            }
        };

        if let Err(err) = project_file.write_all(manifest_str.as_bytes()) {
            miette::bail!(
                "Failed to write project manifest to '{}'. {err}",
                project_toml_path.display()
            );
        };

        Ok(Project {
            path: project_path,
            file: project_file,
            manifest,
        })
    }

    pub fn open(path: &Path) -> miette::Result<Self> {
        let mut file = std::fs::File::options()
            .read(true)
            .write(true)
            .open(path)
            .map_err(|err| {
                miette::miette!(
                    "Cannot open project at {}, failed to open \"Arcana.toml\": {err}",
                    path.display()
                )
            })?;

        let mut arcana_toml = String::new();
        file.read_to_string(&mut arcana_toml).map_err(|err| {
            miette::miette!(
                "Cannot read project manifest from \"{}\\Arcana.toml\": {err}",
                path.display()
            )
        })?;

        let manifest: ProjectManifest = toml::from_str(&arcana_toml).map_err(|err| {
            miette::miette!("Cannot deserialize project manifest from \"Arcana.toml\": {err}")
        })?;

        let file_path = dunce::canonicalize(path).expect("existing path");
        let project_path = file_path.parent().expect("parent path");

        let project = Project {
            path: project_path.to_owned(),
            file,
            manifest,
        };

        Ok(project)
    }

    pub fn name(&self) -> &str {
        &self.manifest.name
    }

    pub fn add_library_path(&mut self, path: &Path) -> miette::Result<()> {
        let path_str = path.to_str().ok_or_else(|| {
            miette::miette!(
                "Cannot add library path \"{}\": path is not valid UTF-8",
                path.display()
            )
        })?;

        let cargo_toml_path = path.join("Cargo.toml");

        let cargo_toml = std::fs::read_to_string(&cargo_toml_path).map_err(|err| {
            miette::miette!(
                "Cannot read Cargo.toml from \"{}\": {err}",
                cargo_toml_path.display()
            )
        })?;

        let manifest = cargo_toml::Manifest::from_str(&cargo_toml).map_err(|err| {
            miette::miette!(
                "Cannot read Cargo.toml from \"{}\": {err}",
                cargo_toml_path.display()
            )
        })?;

        let package = manifest.package.as_ref().ok_or_else(|| {
            miette::miette!("Not a package manifest: \"{}\"", cargo_toml_path.display())
        })?;

        self.manifest.plugin_libs.insert(
            package.name.clone(),
            Dependency::Path {
                path: path_str.to_owned(),
            },
        );

        self.sync()?;

        Ok(())
    }

    fn sync(&mut self) -> miette::Result<()> {
        let content = toml::to_string_pretty(&self.manifest).map_err(|err| {
            miette::miette!("Cannot serialize project manifest to \"Arcana.toml\": {err}")
        })?;

        self.write_to_file(&content).map_err(|err| {
            miette::miette!(
                "Cannot write project manifest to \"{}\\Arcana.toml\": {err}",
                self.path.display()
            )
        })?;

        Ok(())
    }

    fn write_to_file(&mut self, content: &str) -> std::io::Result<()> {
        self.file.seek(SeekFrom::Start(0))?;
        self.file.set_len(0)?;
        self.file.write_all(content.as_bytes())
    }

    /// Returns content for `Cargo.toml` file.
    fn cargo_toml(&self) -> String {
        let mut cargo_toml = format!(
            r#"
[package]
name = "{name}"
version = "0.0.0"
edition = "2021"
publish = false

[lib]
crate-type = ["cdylib"]

[dependencies]
arcana = {arcana}
"#,
            name = self.manifest.name.escape_default(),
            arcana = self.manifest.arcana,
        );

        for (name, dep) in &self.manifest.plugin_libs {
            cargo_toml.push_str(&format!("{} = {}\n", name, dep));
        }

        cargo_toml
    }

    fn lib_rs(&self) -> String {
        let mut lib_rs = "ed::ed_lib![".to_owned();
        for lib in &self.manifest.plugin_libs {
            lib_rs.push_str(&lib.0.replace('-', "_"));
            lib_rs.push(',');
        }
        lib_rs.push_str("];");
        lib_rs
    }

    fn init_package(&self) -> miette::Result<()> {
        if !self.path.exists() {
            std::fs::create_dir_all(&self.path).map_err(|err| {
                miette::miette!(
                    "Failed to create build directory at {}: {err}",
                    self.path.display()
                )
            })?;
        }

        let cargo_toml_path = self.path.join("Cargo.toml");
        std::fs::write(&cargo_toml_path, self.cargo_toml()).map_err(|err| {
            miette::miette!(
                "Failed to write Cargo.toml to {}: {err}",
                cargo_toml_path.display()
            )
        })?;

        let src_path = self.path.join("src");
        if !src_path.exists() {
            std::fs::create_dir_all(&src_path).map_err(|err| {
                miette::miette!(
                    "Failed to create src directory at {}: {err}",
                    src_path.display()
                )
            })?;
        }

        let src_lib_rs_path = src_path.join("lib.rs");
        std::fs::write(&src_lib_rs_path, self.lib_rs()).map_err(|err| {
            miette::miette!(
                "Failed to write src/lib.rs to {}: {err}",
                src_lib_rs_path.display()
            )
        })?;

        Ok(())
    }

    pub fn build(&self, instance: &mut Option<ProjectInstance>) -> miette::Result<()> {
        self.init_package()?;

        let result = std::process::Command::new("cargo")
            .arg("build")
            .arg("--lib")
            .arg(format!("--package={}", self.manifest.name))
            .current_dir(&self.path)
            .status();

        match result {
            Err(err) => {
                return Err(miette::miette!("Failed to run cargo build: {}", err));
            }
            Ok(status) if !status.success() => {
                return Err(miette::miette!(
                    "Failed build project: {}",
                    status.to_string()
                ));
            }
            Ok(_) => {}
        }

        let workspace = find_workspace_target(&self.path);
        let target_path = workspace.join("target").join("debug");

        let mut bin = ProjectLibrary::new(&self.manifest.name, &target_path)?;

        let mut new_plugins = HashMap::new();

        for (lib, plugins) in bin.list_plugins() {
            let lib = new_plugins.entry(lib).or_insert_with(HashMap::new);

            for plugin in plugins {
                lib.insert(plugin, false);
            }
        }

        if let Some(old) = &*instance {
            for (lib, old_plugins) in &old.plugins {
                if let Some(new_plugins) = new_plugins.get_mut(lib) {
                    for (plugin, enabled) in new_plugins {
                        if let Some(old_enabled) = old_plugins.get(plugin) {
                            *enabled = *old_enabled;
                        }
                    }
                }
            }
        }

        *instance = Some(ProjectInstance {
            plugins: new_plugins,
            bin,
        });

        Ok(())
    }
}

pub struct ProjectInstance {
    plugins: HashMap<String, HashMap<String, bool>>,
    bin: ProjectLibrary,
}

impl ProjectInstance {
    pub fn plugins(&self) -> &HashMap<String, HashMap<String, bool>> {
        &self.plugins
    }

    pub fn plugins_enabled_mut(
        &mut self,
    ) -> impl Iterator<Item = (&str, impl Iterator<Item = (&str, &mut bool)>)> {
        self.plugins.iter_mut().map(|(lib, plugins)| {
            (
                &**lib,
                plugins
                    .iter_mut()
                    .map(|(plugin, enabled)| (&**plugin, enabled)),
            )
        })
    }

    pub fn launch(
        &mut self,
        events: &EventLoop,
        device: &mev::Device,
        queue: &Arc<Mutex<mev::Queue>>,
    ) {
        self.bin.launch(
            events,
            device,
            queue,
            self.plugins.iter().flat_map(|(lib, plugins)| {
                plugins.iter().filter_map(move |(plugin, enabled)| {
                    if *enabled {
                        Some((&**lib, &**plugin))
                    } else {
                        None
                    }
                })
            }),
        );
    }

    pub fn on_event(&mut self, event: Event) -> Option<Event> {
        self.bin.on_event(event)
    }

    pub fn tick(&mut self) {
        self.bin.tick();
    }
}

fn find_workspace_target(path: &Path) -> &Path {
    let mut candidate = path;
    let mut next = Some(path);

    while let Some(path) = next {
        if path.join("Cargo.toml").is_file() {
            candidate = path;
        }
        next = path.parent();
    }

    candidate
}

fn invalid_name_character(c: char) -> bool {
    !c.is_alphanumeric() && c != '_'
}
