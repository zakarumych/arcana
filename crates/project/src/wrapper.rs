//! This module generates the wrapper libs for plugins libraries.

use std::{
    env::consts::{DLL_PREFIX, DLL_SUFFIX},
    path::{Path, PathBuf},
    process::Command,
};

use super::Dependency;

macro_rules! make_workspace_cargo_toml {
    ($arcana:expr, $name:ident, $plugins:expr) => {
        format!(
            r#"
# This file is automatically generated for Arcana Project.
# Do not edit manually.
[package]
name = "{name}"
publish = false

[[bin]]
name = "ed"
src = "src/ed.rs"

[[bin]]
name = "{name}"
src = "src/main.rs"

[dependencies]
arcana = {arcana}

[workspace]
members = {members:?}
            "#,
            name = stringify!($name),
            arcana = $arcana,
            members = $plugins,
        )
    };
}

macro_rules! make_workspace_main_rs {
    ($name:ident) => {
        format!(
            r#"
//! This file is automatically generated for Arcana Project.
//! Do not edit manually.

fn main() {{
    todo!();
}}
"#
        )
    };
}

macro_rules! make_workspace_ed_rs {
    ($name:ident) => {
        format!(
            r#"
//! This file is automatically generated for Arcana Project.
//! Do not edit manually.

// Runs Arcana Ed.
fn main() {{
    arcana::ed::run(env!("CARGO_MANIFEST_DIR"));
}}
"#
        )
    };
}

macro_rules! make_plugin_cargo_toml {
    ($arcana:expr, $name:ident = $dependency:expr) => {
        format!(
            r#"
# This file is automatically generated to wrap '{name}' crate
# into dynamically linked library.
# Do not edit manually.
[package]
name = "{name}-arcana-plugin"
publish = false

[lib]
crate-type = ["cdylib"]

[dependencies]
arcana = {arcana}
{name} = {dependency}
"#,
            name = stringify!($name),
            arcana = $arcana,
            dependency = $dependency
        )
    };
}

macro_rules! make_plugin_lib_rs {
    ($name:ident) => {
        format!(
            r#"
//! This file is automatically generated to wrap '{name}' crate
//! into dynamically linked library.
//! Do not edit manually.

/// Exports plugins for Arcana Engine from plugins library.
#[no_mangle]
pub fn arcana_plugins() -> &'static [&'static arcana::plugin::ArcanaPlugin] {{
    // This method must be generated by the
    // `export_arcana_plugins!` macro in the plugins crate workspace.
    {name}::__arcana_plugins()
}}
"#,
            name = $name
        )
    };
}

pub fn init_workspace<I, S>(
    arcana: Option<&Dependency>,
    plugins: I,
    root: &Path,
) -> miette::Result<()>
where
    I: IntoIterator<Item = S>,
    S: AsRef<str>,
{
    let workspace = root.join("workspace");
    std::fs::create_dir_all(&workspace).map_err(|err| {
        miette::miette!(
            "Failed to create project workspace directory '{}'. {err}",
            workspace.display()
        )
    })?;

    std::fs::write(workspace.join(".gitignore"), b"*").map_err(|err| {
        miette::miette!(
            "Failed to create workspace .gitignore file '{}'. {err}",
            workspace.display()
        )
    })?;

    let src_dir = workspace.join("src");
    std::fs::create_dir_all(&src_dir).map_err(|err| {
        miette::miette!(
            "Failed to create workspace src directory '{}'. {err}",
            src_dir.display()
        )
    })?;

    let plugins = plugins
        .into_iter()
        .map(|plugin| format!("plugins/{}", plugin.as_ref().escape_default()))
        .collect::<Vec<_>>();

    let cargo_toml = match arcana {
        None => make_workspace_cargo_toml!(env!("CARGO_PKG_VERSION"), name, plugins),
        Some(arcana) => make_workspace_cargo_toml!(arcana, name, plugins),
    };

    std::fs::write(workspace.join("Cargo.toml"), cargo_toml).map_err(|err| {
        miette::miette!(
            "Failed to write workspace Cargo.toml file '{}'. {err}",
            workspace.display()
        )
    })?;

    let main_rs = make_workspace_main_rs!(name);
    std::fs::write(src_dir.join("main.rs"), main_rs).map_err(|err| {
        miette::miette!(
            "Failed to write workspace main.rs file '{}'. {err}",
            src_dir.display()
        )
    })?;

    let ed_rs = make_workspace_ed_rs!(name);
    std::fs::write(src_dir.join("ed.rs"), ed_rs).map_err(|err| {
        miette::miette!(
            "Failed to write workspace ed.rs file '{}'. {err}",
            src_dir.display()
        )
    })?;

    Ok(())
}

pub fn init_plugin(
    name: &str,
    dependency: &Dependency,
    arcana: Option<&Dependency>,
    root: &Path,
) -> miette::Result<()> {
    let workspace = root.join("workspace");

    let cargo_toml = match arcana {
        None => make_plugin_cargo_toml!(env!("CARGO_PKG_VERSION"), name = dependency),
        Some(arcana) => make_plugin_cargo_toml!(arcana, name = dependency),
    };

    let lib_rs = make_plugin_lib_rs!(name);

    let plugin_dir = workspace.join("plugins").join(name);
    std::fs::create_dir_all(&plugin_dir).map_err(|err| {
        miette::miette!(
            "Failed to create plugin directory '{}'. {err}",
            plugin_dir.display()
        )
    })?;

    let src_dir = plugin_dir.join("src");
    std::fs::create_dir_all(&src_dir).map_err(|err| {
        miette::miette!(
            "Failed to create plugin src directory '{}'. {err}",
            src_dir.display()
        )
    })?;

    let cargo_toml_path = plugin_dir.join("Cargo.toml");
    let lib_rs_path = src_dir.join("lib.rs");

    std::fs::write(&cargo_toml_path, cargo_toml).map_err(|err| {
        miette::miette!(
            "Failed to write plugin Cargo.toml file '{}'. {err}",
            cargo_toml_path.display()
        )
    })?;

    std::fs::write(&lib_rs_path, lib_rs).map_err(|err| {
        miette::miette!(
            "Failed to write plugin lib.rs file '{}'. {err}",
            lib_rs_path.display()
        )
    })?;

    Ok(())
}

pub fn build_project(name: &str, root: &Path) -> miette::Result<()> {
    let workspace = root.join("workspace");

    let status = std::process::Command::new("cargo")
        .arg("build")
        .arg(format!("--package={}", name))
        .current_dir(&workspace)
        .status()
        .map_err(|err| {
            miette::miette!(
                "Failed to build project '{name}' in '{}'. {err}",
                workspace.display()
            )
        })?;

    if !status.success() {
        miette::bail!(
            "Failed to build project '{name}' in '{}'.",
            workspace.display()
        );
    }

    Ok(())
}

pub fn run_editor(name: &str, root: &Path) -> Command {
    let workspace = root.join("workspace");
    let mut cmd = Command::new("cargo");
    cmd.arg("run")
        .arg(format!("--package={}", name))
        .arg("--bin=ed")
        .current_dir(&workspace);
    cmd
}

pub fn build_plugin(name: &str, root: &Path) -> miette::Result<()> {
    let workspace = root.join("workspace");

    let status = Command::new("cargo")
        .arg("build")
        .arg(format!("--package={}-arcana-plugin", name))
        .current_dir(&workspace)
        .status()
        .map_err(|err| {
            miette::miette!(
                "Failed to build plugin '{name}' in '{}'. {err}",
                workspace.display()
            )
        })?;

    if !status.success() {
        miette::bail!(
            "Failed to build plugin '{name}' in '{}'.",
            workspace.display()
        );
    }

    Ok(())
}

pub fn plugin_lib_path(name: &str, root: &Path) -> miette::Result<PathBuf> {
    build_plugin(name, root)?;

    let lib_path = root
        .join("workspace")
        .join("target")
        .join("debug")
        .join(format!("{DLL_PREFIX}{name}-arcana-plugin{DLL_SUFFIX}"));

    Ok(lib_path)
}
